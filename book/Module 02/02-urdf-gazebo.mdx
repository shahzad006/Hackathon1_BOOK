---
title: 'Spawning Robot Models'
description: 'Spawning and controlling robot models in Gazebo simulation'
---

# Spawning Robot Models

## Overview

After creating URDF robot descriptions, the next step is bringing them to life in Gazebo. This section covers converting URDF to Gazebo-compatible SDF, spawning robots in simulation worlds, and configuring physics properties for realistic behavior.

## URDF to Gazebo: Key Differences

While URDF describes robot structure, Gazebo requires additional tags for simulation:

- **Gazebo-specific properties**: Friction, damping, sensor plugins
- **Material colors**: Visual appearance beyond simple RGBA
- **Plugin configurations**: Controllers, sensors, custom behaviors
- **Physics parameters**: Contact models, ODE/DART settings

## Adding Gazebo Tags to URDF

Enhance your URDF with Gazebo extensions:

```xml
<?xml version="1.0"?>
<robot name="humanoid_gazebo">
  <!-- ... existing URDF links and joints ... -->

  <!-- Gazebo-specific link properties -->
  <gazebo reference="torso">
    <material>Gazebo/Blue</material>
    <mu1>0.8</mu1>  <!-- Friction coefficient 1 -->
    <mu2>0.8</mu2>  <!-- Friction coefficient 2 -->
    <kp>1000000.0</kp>  <!-- Contact stiffness -->
    <kd>100.0</kd>  <!-- Contact damping -->
    <maxVel>0.01</maxVel>
    <minDepth>0.001</minDepth>
  </gazebo>

  <!-- Foot contact properties for humanoids -->
  <gazebo reference="left_foot">
    <material>Gazebo/Grey</material>
    <mu1>1.5</mu1>  <!-- Higher friction for walking -->
    <mu2>1.5</mu2>
    <kp>10000000.0</kp>
    <kd>1000.0</kd>
    <maxVel>0.0</maxVel>
    <minDepth>0.001</minDepth>
    <maxContacts>20</maxContacts>  <!-- Multiple contact points -->
  </gazebo>

  <!-- Joint damping and friction -->
  <gazebo reference="left_hip_pitch">
    <implicitSpringDamper>true</implicitSpringDamper>
    <springStiffness>0.0</springStiffness>
    <springReference>0.0</springReference>
    <dampingFactor>0.1</dampingFactor>
  </gazebo>
</robot>
```

## Spawning Robots in Gazebo

### Method 1: Using ros2_control and Gazebo ROS 2 Control

Create a launch file to spawn your robot:

```python
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
import os

def generate_launch_description():
    # Get paths
    pkg_share = FindPackageShare('humanoid_description').find('humanoid_description')
    urdf_file = os.path.join(pkg_share, 'urdf', 'humanoid.urdf')

    # Read URDF
    with open(urdf_file, 'r') as file:
        robot_description = file.read()

    # Start Gazebo
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            PathJoinSubstitution([
                FindPackageShare('gazebo_ros'),
                'launch',
                'gazebo.launch.py'
            ])
        ]),
        launch_arguments={'world': 'empty.world'}.items()
    )

    # Spawn robot
    spawn_entity = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-entity', 'humanoid_robot',
            '-topic', 'robot_description',
            '-x', '0.0',
            '-y', '0.0',
            '-z', '1.0'
        ],
        output='screen'
    )

    # Robot state publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{'robot_description': robot_description}],
        output='screen'
    )

    return LaunchDescription([
        gazebo,
        robot_state_publisher,
        spawn_entity
    ])
```

### Method 2: Direct SDF Inclusion

For complex worlds, include robot directly in SDF:

```xml
<sdf version="1.8">
  <world name="humanoid_world">
    <!-- ... world elements ... -->

    <include>
      <uri>model://humanoid_robot</uri>
      <pose>0 0 1 0 0 0</pose>
      <name>my_humanoid</name>
    </include>
  </world>
</sdf>
```

## Configuring Physics for Humanoids

### Contact Dynamics

Critical for bipedal walking and grasping:

```xml
<gazebo>
  <physics type="ode">
    <max_step_size>0.001</max_step_size>
    <real_time_factor>1.0</real_time_factor>
    <real_time_update_rate>1000.0</real_time_update_rate>

    <!-- ODE physics properties -->
    <ode>
      <solver>
        <type>quick</type>
        <iters>50</iters>
        <sor>1.3</sor>
      </solver>
      <constraints>
        <cfm>0.0</cfm>
        <erp>0.2</erp>
        <contact_max_correcting_vel>100.0</contact_max_correcting_vel>
        <contact_surface_layer>0.001</contact_surface_layer>
      </constraints>
    </ode>
  </physics>
</gazebo>
```

### Switching to DART Physics

DART provides better stability for humanoids:

```xml
<gazebo>
  <physics type="dart">
    <max_step_size>0.001</max_step_size>
    <real_time_factor>1.0</real_time_factor>

    <dart>
      <solver>
        <solver_type>dantzig</solver_type>
      </solver>
      <collision_detector>bullet</collision_detector>
    </dart>
  </physics>
</gazebo>
```

## Adding Joint Controllers

Control robot joints with ros2_control:

```xml
<gazebo>
  <plugin name="gazebo_ros2_control" filename="libgazebo_ros2_control.so">
    <parameters>$(find humanoid_description)/config/controllers.yaml</parameters>
  </plugin>
</gazebo>

<ros2_control name="GazeboSystem" type="system">
  <hardware>
    <plugin>gazebo_ros2_control/GazeboSystem</plugin>
  </hardware>

  <joint name="left_hip_pitch">
    <command_interface name="position">
      <param name="min">-1.57</param>
      <param name="max">1.57</param>
    </command_interface>
    <state_interface name="position"/>
    <state_interface name="velocity"/>
    <state_interface name="effort"/>
  </joint>

  <!-- Repeat for all actuated joints -->
</ros2_control>
```

Controller configuration (`controllers.yaml`):

```yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz

    joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster

    position_controller:
      type: position_controllers/JointGroupPositionController

position_controller:
  ros__parameters:
    joints:
      - left_hip_pitch
      - left_hip_roll
      - left_knee
      - left_ankle_pitch
      # ... all joints
```

## Testing Robot Stability

Verify robot doesn't fall through ground or explode:

```bash
# Launch Gazebo with robot
ros2 launch humanoid_description gazebo.launch.py

# Check joint states
ros2 topic echo /joint_states

# Monitor physics performance
gz topic -e /gazebo/performance_metrics

# Send test commands
ros2 topic pub /position_controller/commands std_msgs/Float64MultiArray "data: [0.1, 0.0, -0.2, 0.1, 0.0, 0.0]"
```

## Common Issues and Fixes

### Robot Falls Through Ground
- Check collision geometries exist
- Verify ground plane has collision enabled
- Increase contact stiffness (kp)

### Joints are Jittery
- Reduce time step size (max_step_size)
- Increase damping coefficients
- Use DART instead of ODE physics

### Simulation Runs Slow
- Simplify collision meshes
- Reduce solver iterations
- Disable shadows and high-quality rendering

### Robot Explodes on Contact
- Check inertia tensors are positive-definite
- Reduce contact stiffness initially
- Validate URDF with `check_urdf`

## Benchmarking Physics Engines

| Engine | Accuracy | Speed | Contact Stability | Best For |
|--------|----------|-------|-------------------|----------|
| ODE | Medium | Fast | Medium | Simple robots |
| Bullet | High | Medium | High | Manipulation |
| DART | High | Fast | Very High | Humanoids, legged robots |
| Simbody | Very High | Slow | Very High | Research, biomechanics |

## Key Takeaways

- Gazebo tags extend URDF with simulation-specific properties
- Contact dynamics (friction, stiffness) are critical for humanoids
- DART physics engine provides best stability for legged robots
- ros2_control bridges simulation and hardware controllers
- Always validate physics behavior before RL training

## References

- [Gazebo ROS 2 Integration](https://gazebosim.org/docs/harmonic/ros2_integration)
- [gazebo_ros_pkgs](https://github.com/ros-simulation/gazebo_ros_pkgs)
- [ros2_control Gazebo Plugin](https://control.ros.org/master/doc/gazebo_ros2_control/doc/index.html)
- [DART Physics](https://dartsim.github.io/)

## Next Steps

With robots simulated in Gazebo, we'll add sensors (cameras, IMUs, lidars) and integrate sensor data with ROS 2 perception pipelines.
