---
title: 'Services and Actions'
description: 'Request-response patterns and long-running tasks in ROS 2'
---

# Services and Actions

## Overview

While topics provide asynchronous communication, robotics often requires request-response patterns or feedback on long-running tasks. ROS 2 services enable synchronous client-server interactions, while actions support preemptable, goal-oriented operations with continuous feedback.

## Services: Synchronous Request-Response

Services implement a client-server pattern where a client sends a request and blocks until receiving a response. This is ideal for quick computations or state queries that complete immediately.

### Use Cases for Services

- Getting current robot state
- Computing inverse kinematics
- Triggering calibration routines
- Resetting simulation environments
- Querying sensor status

### Creating a Service Server

Let's create a service that computes inverse kinematics for a robot arm:

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.srv import GetPose
from geometry_msgs.msg import Pose
import numpy as np

class IKServiceNode(Node):
    def __init__(self):
        super().__init__('ik_service')
        self.srv = self.create_service(
            GetPose,
            '/robot/compute_ik',
            self.compute_ik_callback
        )
        self.get_logger().info('IK service ready')

    def compute_ik_callback(self, request, response):
        # Extract target pose from request
        target_pose = request.pose

        # Compute inverse kinematics (simplified example)
        joint_positions = self.solve_ik(target_pose)

        # Populate response
        response.joint_positions = joint_positions
        response.success = True

        self.get_logger().info(f'IK solved for pose: {target_pose.position}')
        return response

    def solve_ik(self, target_pose):
        # Simplified IK computation
        # In practice, use KDL, TRAC-IK, or custom solvers
        return [0.5, -0.3, 1.2, 0.0, 0.8, 0.0]

def main():
    rclpy.init()
    node = IKServiceNode()
    rclpy.spin(node)
    rclpy.shutdown()
```

### Creating a Service Client

Now let's call this service:

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.srv import GetPose
from geometry_msgs.msg import Pose, Point

class IKClientNode(Node):
    def __init__(self):
        super().__init__('ik_client')
        self.client = self.create_client(GetPose, '/robot/compute_ik')

        # Wait for service to be available
        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for IK service...')

    def call_ik_service(self, x, y, z):
        request = GetPose.Request()
        request.pose.position = Point(x=x, y=y, z=z)

        # Synchronous call
        future = self.client.call_async(request)
        rclpy.spin_until_future_complete(self, future)

        if future.result() is not None:
            response = future.result()
            self.get_logger().info(f'IK result: {response.joint_positions}')
            return response.joint_positions
        else:
            self.get_logger().error('Service call failed')
            return None

def main():
    rclpy.init()
    node = IKClientNode()
    node.call_ik_service(0.5, 0.3, 0.8)
    node.destroy_node()
    rclpy.shutdown()
```

## Actions: Long-Running Tasks with Feedback

Actions extend services with three key features:
1. **Feedback**: Periodic progress updates during execution
2. **Preemption**: Cancel goals mid-execution
3. **Asynchronous**: Non-blocking goal submission

### Use Cases for Actions

- Navigation to waypoints
- Grasping objects
- Trajectory execution
- Multi-step manipulation sequences
- Balance recovery

### Creating an Action Server

Let's create an action for executing a joint trajectory:

```python
import rclpy
from rclpy.action import ActionServer
from rclpy.node import Node
from control_msgs.action import FollowJointTrajectory
import time

class TrajectoryActionServer(Node):
    def __init__(self):
        super().__init__('trajectory_action_server')
        self._action_server = ActionServer(
            self,
            FollowJointTrajectory,
            '/robot/follow_trajectory',
            self.execute_callback
        )
        self.get_logger().info('Trajectory action server started')

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing trajectory...')

        # Extract trajectory points
        trajectory = goal_handle.request.trajectory
        feedback_msg = FollowJointTrajectory.Feedback()

        # Execute each waypoint
        for i, point in enumerate(trajectory.points):
            # Check if goal was canceled
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                return FollowJointTrajectory.Result()

            # Simulate trajectory execution
            self.move_to_waypoint(point.positions)

            # Publish feedback
            feedback_msg.header.stamp = self.get_clock().now().to_msg()
            feedback_msg.joint_names = trajectory.joint_names
            feedback_msg.actual.positions = point.positions
            goal_handle.publish_feedback(feedback_msg)

            time.sleep(0.1)  # Simulate movement time

        # Mark as succeeded
        goal_handle.succeed()

        result = FollowJointTrajectory.Result()
        result.error_code = FollowJointTrajectory.Result.SUCCESSFUL
        return result

    def move_to_waypoint(self, positions):
        # Send commands to robot hardware
        pass

def main():
    rclpy.init()
    node = TrajectoryActionServer()
    rclpy.spin(node)
```

### Creating an Action Client

Now let's send a trajectory goal:

```python
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from control_msgs.action import FollowJointTrajectory
from trajectory_msgs.msg import JointTrajectoryPoint

class TrajectoryActionClient(Node):
    def __init__(self):
        super().__init__('trajectory_action_client')
        self._action_client = ActionClient(
            self,
            FollowJointTrajectory,
            '/robot/follow_trajectory'
        )

    def send_goal(self, waypoints):
        goal_msg = FollowJointTrajectory.Goal()
        goal_msg.trajectory.joint_names = ['joint1', 'joint2', 'joint3']

        # Add waypoints
        for i, waypoint in enumerate(waypoints):
            point = JointTrajectoryPoint()
            point.positions = waypoint
            point.time_from_start.sec = i
            goal_msg.trajectory.points.append(point)

        # Wait for server
        self._action_client.wait_for_server()

        # Send goal asynchronously
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info(f'Current position: {feedback.actual.positions}')

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            return

        self.get_logger().info('Goal accepted')
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        self.get_logger().info(f'Trajectory completed: {result.error_code}')

def main():
    rclpy.init()
    node = TrajectoryActionClient()

    # Define waypoints
    waypoints = [
        [0.0, 0.0, 0.0],
        [0.5, -0.3, 0.8],
        [1.0, -0.5, 1.2]
    ]

    node.send_goal(waypoints)
    rclpy.spin(node)
```

## Services vs Actions: When to Use Which

| Feature | Service | Action |
|---------|---------|--------|
| Execution Time | < 1 second | > 1 second |
| Feedback | No | Yes |
| Cancellation | No | Yes |
| Blocking | Yes | No (async) |
| Examples | Get state, compute IK | Navigate, grasp, follow trajectory |

---

## Advanced Service Patterns

### Asynchronous Service Calls

For non-blocking service calls in complex nodes:

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class AsyncServiceClient(Node):
    def __init__(self):
        super().__init__('async_client')

        self.client = self.create_client(AddTwoInts, 'add_two_ints')

        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for service...')

    def send_request_async(self, a, b):
        request = AddTwoInts.Request()
        request.a = a
        request.b = b

        # Send asynchronously
        future = self.client.call_async(request)
        future.add_done_callback(self.response_callback)

        return future

    def response_callback(self, future):
        try:
            response = future.result()
            self.get_logger().info(f'Result: {response.sum}')
        except Exception as e:
            self.get_logger().error(f'Service call failed: {e}')

def main():
    rclpy.init()
    node = AsyncServiceClient()

    # Send multiple requests without blocking
    node.send_request_async(1, 2)
    node.send_request_async(5, 7)
    node.send_request_async(10, 20)

    rclpy.spin(node)
    rclpy.shutdown()
```

### Service with Timeout Handling

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts
from rclpy.executors import MultiThreadedExecutor
import threading

class RobustServiceClient(Node):
    def __init__(self):
        super().__init__('robust_client')
        self.client = self.create_client(AddTwoInts, 'add_two_ints')

    def call_with_timeout(self, a, b, timeout_sec=5.0):
        if not self.client.wait_for_service(timeout_sec=2.0):
            self.get_logger().error('Service not available')
            return None

        request = AddTwoInts.Request()
        request.a = a
        request.b = b

        future = self.client.call_async(request)

        # Wait with timeout
        start_time = self.get_clock().now()
        while rclpy.ok():
            rclpy.spin_once(self, timeout_sec=0.1)

            if future.done():
                try:
                    return future.result()
                except Exception as e:
                    self.get_logger().error(f'Service call failed: {e}')
                    return None

            elapsed = (self.get_clock().now() - start_time).nanoseconds / 1e9
            if elapsed > timeout_sec:
                self.get_logger().error(f'Service call timed out after {timeout_sec}s')
                return None

def main():
    rclpy.init()
    client = RobustServiceClient()

    result = client.call_with_timeout(10, 15, timeout_sec=3.0)

    if result:
        client.get_logger().info(f'Success: {result.sum}')
    else:
        client.get_logger().error('Failed to get result')

    client.destroy_node()
    rclpy.shutdown()
```

---

## Custom Service Definitions

### Creating a Complex Service

Create `srv/GetRobotState.srv`:

```
# Request
string[] requested_joints
bool include_velocities
bool include_efforts
---
# Response
string[] joint_names
float64[] positions
float64[] velocities  # Empty if not requested
float64[] efforts     # Empty if not requested
bool success
string message
```

### Implementing the Service

```python
import rclpy
from rclpy.node import Node
from humanoid_srvs.srv import GetRobotState

class RobotStateServer(Node):
    def __init__(self):
        super().__init__('robot_state_server')

        self.srv = self.create_service(
            GetRobotState,
            'get_robot_state',
            self.get_state_callback
        )

        # Simulated robot state
        self.joint_states = {
            'shoulder_pan': {'pos': 0.5, 'vel': 0.1, 'eff': 2.0},
            'shoulder_lift': {'pos': -0.3, 'vel': 0.0, 'eff': 1.5},
            'elbow': {'pos': 1.2, 'vel': 0.2, 'eff': 0.8},
        }

        self.get_logger().info('Robot state service ready')

    def get_state_callback(self, request, response):
        requested = request.requested_joints

        # Validate requested joints
        invalid_joints = [j for j in requested if j not in self.joint_states]
        if invalid_joints:
            response.success = False
            response.message = f'Invalid joints: {invalid_joints}'
            return response

        # Build response
        response.joint_names = requested
        response.positions = [self.joint_states[j]['pos'] for j in requested]

        if request.include_velocities:
            response.velocities = [self.joint_states[j]['vel'] for j in requested]

        if request.include_efforts:
            response.efforts = [self.joint_states[j]['eff'] for j in requested]

        response.success = True
        response.message = f'Retrieved state for {len(requested)} joints'

        self.get_logger().info(f'Served state for: {requested}')

        return response

def main():
    rclpy.init()
    node = RobotStateServer()
    rclpy.spin(node)
    rclpy.shutdown()
```

---

## Advanced Action Patterns

### Action with Partial Results

```python
import rclpy
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.node import Node
from my_robot_interfaces.action import ProcessImages
import time

class ImageProcessingServer(Node):
    def __init__(self):
        super().__init__('image_processing_server')

        self._action_server = ActionServer(
            self,
            ProcessImages,
            'process_images',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback
        )

        self.get_logger().info('Image processing action server started')

    def goal_callback(self, goal_request):
        """Accept or reject goal requests"""
        num_images = goal_request.num_images

        if num_images > 100:
            self.get_logger().warn(f'Rejecting goal: too many images ({num_images})')
            return GoalResponse.REJECT

        self.get_logger().info(f'Accepting goal: {num_images} images')
        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        """Handle cancellation requests"""
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')

        num_images = goal_handle.request.num_images
        feedback_msg = ProcessImages.Feedback()

        processed_images = []

        for i in range(num_images):
            # Check if canceled
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                result = ProcessImages.Result()
                result.processed_count = i
                result.success = False
                result.message = 'Goal canceled'
                return result

            # Simulate processing
            time.sleep(0.1)
            processed_images.append(f'image_{i}.jpg')

            # Send feedback
            feedback_msg.current_image = i + 1
            feedback_msg.progress_percentage = ((i + 1) / num_images) * 100.0
            feedback_msg.processed_images = processed_images.copy()

            goal_handle.publish_feedback(feedback_msg)

            self.get_logger().info(f'Processed {i + 1}/{num_images}')

        # Success
        goal_handle.succeed()

        result = ProcessImages.Result()
        result.processed_count = num_images
        result.success = True
        result.message = 'All images processed successfully'
        result.output_images = processed_images

        return result

def main():
    rclpy.init()
    node = ImageProcessingServer()
    rclpy.spin(node)
    rclpy.shutdown()
```

### Action Client with Cancel

```python
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from my_robot_interfaces.action import ProcessImages

class ImageProcessingClient(Node):
    def __init__(self):
        super().__init__('image_processing_client')

        self._action_client = ActionClient(
            self,
            ProcessImages,
            'process_images'
        )

        self._goal_handle = None

    def send_goal(self, num_images):
        goal_msg = ProcessImages.Goal()
        goal_msg.num_images = num_images

        self._action_client.wait_for_server()

        self.get_logger().info(f'Sending goal: process {num_images} images')

        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )

        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        self._goal_handle = future.result()

        if not self._goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            return

        self.get_logger().info('Goal accepted')

        self._get_result_future = self._goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info(
            f'Progress: {feedback.progress_percentage:.1f}% '
            f'({feedback.current_image} images)'
        )

        # Example: Cancel if taking too long
        if feedback.current_image > 50:
            self.get_logger().warn('Taking too long, canceling...')
            self.cancel_goal()

    def get_result_callback(self, future):
        result = future.result().result
        status = future.result().status

        if status == 4:  # SUCCEEDED
            self.get_logger().info(
                f'SUCCESS: Processed {result.processed_count} images'
            )
        elif status == 5:  # CANCELED
            self.get_logger().warn('Goal was canceled')
        else:
            self.get_logger().error(f'Goal failed with status: {status}')

    def cancel_goal(self):
        if self._goal_handle:
            self.get_logger().info('Canceling goal...')
            cancel_future = self._goal_handle.cancel_goal_async()
            cancel_future.add_done_callback(self.cancel_response_callback)

    def cancel_response_callback(self, future):
        cancel_response = future.result()
        if len(cancel_response.goals_canceling) > 0:
            self.get_logger().info('Goal successfully canceled')
        else:
            self.get_logger().error('Failed to cancel goal')

def main():
    rclpy.init()
    client = ImageProcessingClient()
    client.send_goal(100)
    rclpy.spin(client)
    rclpy.shutdown()
```

---

## Debugging Services and Actions

### Command-Line Tools

```bash
# List all services
ros2 service list

# Show service type
ros2 service type /get_robot_state

# Call a service
ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{a: 5, b: 10}"

# List all actions
ros2 action list

# Show action type
ros2 action type /process_images

# Send action goal
ros2 action send_goal /process_images my_robot_interfaces/action/ProcessImages "{num_images: 10}"

# Send action goal with feedback
ros2 action send_goal /process_images my_robot_interfaces/action/ProcessImages "{num_images: 10}" --feedback
```

### Monitoring Service Health

```python
import rclpy
from rclpy.node import Node

class ServiceMonitor(Node):
    def __init__(self):
        super().__init__('service_monitor')

        self.timer = self.create_timer(5.0, self.check_services)

    def check_services(self):
        service_names_and_types = self.get_service_names_and_types()

        self.get_logger().info('=== Available Services ===')
        for name, types in service_names_and_types:
            self.get_logger().info(f'{name}: {types}')

def main():
    rclpy.init()
    node = ServiceMonitor()
    rclpy.spin(node)
    rclpy.shutdown()
```

---

## Practical Exercise: Robot Task Coordination System

### Goal

Build a task coordination system using services and actions:
1. Service for task validation
2. Action for task execution with progress
3. Cancellation support

### Step 1: Task Validation Service

```python title="task_validator.py"
import rclpy
from rclpy.node import Node
from task_interfaces.srv import ValidateTask

class TaskValidator(Node):
    def __init__(self):
        super().__init__('task_validator')

        self.srv = self.create_service(
            ValidateTask,
            'validate_task',
            self.validate_callback
        )

        # Valid task types
        self.valid_tasks = ['pick', 'place', 'navigate', 'scan']

        self.get_logger().info('Task validator ready')

    def validate_callback(self, request, response):
        task_type = request.task_type
        parameters = request.parameters

        # Validate task type
        if task_type not in self.valid_tasks:
            response.is_valid = False
            response.error_message = f'Unknown task type: {task_type}'
            return response

        # Validate parameters
        if task_type == 'pick' and 'object_id' not in parameters:
            response.is_valid = False
            response.error_message = 'Missing object_id parameter'
            return response

        if task_type == 'navigate' and 'target_pose' not in parameters:
            response.is_valid = False
            response.error_message = 'Missing target_pose parameter'
            return response

        response.is_valid = True
        response.error_message = ''
        response.estimated_duration = self.estimate_duration(task_type)

        self.get_logger().info(f'Validated task: {task_type}')

        return response

    def estimate_duration(self, task_type):
        estimates = {
            'pick': 10.0,
            'place': 8.0,
            'navigate': 15.0,
            'scan': 20.0
        }
        return estimates.get(task_type, 10.0)

def main():
    rclpy.init()
    node = TaskValidator()
    rclpy.spin(node)
    rclpy.shutdown()
```

### Step 2: Task Execution Action

```python title="task_executor.py"
import rclpy
from rclpy.action import ActionServer, GoalResponse
from rclpy.node import Node
from task_interfaces.action import ExecuteTask
import time

class TaskExecutor(Node):
    def __init__(self):
        super().__init__('task_executor')

        self._action_server = ActionServer(
            self,
            ExecuteTask,
            'execute_task',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback
        )

        self.get_logger().info('Task executor ready')

    def goal_callback(self, goal_request):
        task_type = goal_request.task_type

        # Simple capacity check
        if hasattr(self, '_current_task') and self._current_task:
            self.get_logger().warn('Already executing a task, rejecting')
            return GoalResponse.REJECT

        self.get_logger().info(f'Accepting task: {task_type}')
        return GoalResponse.ACCEPT

    def execute_callback(self, goal_handle):
        self._current_task = goal_handle.request.task_type

        self.get_logger().info(f'Executing task: {self._current_task}')

        feedback_msg = ExecuteTask.Feedback()
        result = ExecuteTask.Result()

        # Simulate task execution with stages
        stages = ['preparing', 'executing', 'verifying', 'completing']

        for i, stage in enumerate(stages):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                result.success = False
                result.message = f'Task canceled at stage: {stage}'
                self._current_task = None
                return result

            # Update feedback
            feedback_msg.current_stage = stage
            feedback_msg.progress_percentage = ((i + 1) / len(stages)) * 100.0
            goal_handle.publish_feedback(feedback_msg)

            self.get_logger().info(f'Stage: {stage}')

            # Simulate work
            time.sleep(2.0)

        # Success
        goal_handle.succeed()

        result.success = True
        result.message = f'Task {self._current_task} completed successfully'
        result.execution_time = len(stages) * 2.0

        self._current_task = None

        return result

def main():
    rclpy.init()
    node = TaskExecutor()
    rclpy.spin(node)
    rclpy.shutdown()
```

### Step 3: Integrated Task Manager

```python title="task_manager.py"
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from task_interfaces.srv import ValidateTask
from task_interfaces.action import ExecuteTask

class TaskManager(Node):
    def __init__(self):
        super().__init__('task_manager')

        # Service client for validation
        self.validate_client = self.create_client(
            ValidateTask,
            'validate_task'
        )

        # Action client for execution
        self._action_client = ActionClient(
            self,
            ExecuteTask,
            'execute_task'
        )

        self.get_logger().info('Task manager ready')

    def submit_task(self, task_type, parameters):
        # Step 1: Validate task
        self.get_logger().info(f'Validating task: {task_type}')

        if not self.validate_client.wait_for_service(timeout_sec=2.0):
            self.get_logger().error('Validation service not available')
            return

        validate_request = ValidateTask.Request()
        validate_request.task_type = task_type
        validate_request.parameters = parameters

        future = self.validate_client.call_async(validate_request)
        rclpy.spin_until_future_complete(self, future)

        validation_response = future.result()

        if not validation_response.is_valid:
            self.get_logger().error(
                f'Task invalid: {validation_response.error_message}'
            )
            return

        self.get_logger().info(
            f'Task valid, estimated duration: {validation_response.estimated_duration}s'
        )

        # Step 2: Execute task
        self.execute_task(task_type, parameters)

    def execute_task(self, task_type, parameters):
        goal_msg = ExecuteTask.Goal()
        goal_msg.task_type = task_type
        goal_msg.parameters = parameters

        self._action_client.wait_for_server()

        self.get_logger().info('Sending execution goal...')

        send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )

        send_goal_future.add_done_callback(self.goal_response_callback)

    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info(
            f'Stage: {feedback.current_stage}, '
            f'Progress: {feedback.progress_percentage:.1f}%'
        )

    def goal_response_callback(self, future):
        goal_handle = future.result()

        if not goal_handle.accepted:
            self.get_logger().error('Goal rejected')
            return

        self.get_logger().info('Goal accepted, waiting for result...')

        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.result_callback)

    def result_callback(self, future):
        result = future.result().result

        if result.success:
            self.get_logger().info(
                f'SUCCESS: {result.message} '
                f'(took {result.execution_time}s)'
            )
        else:
            self.get_logger().error(f'FAILED: {result.message}')

def main():
    rclpy.init()
    manager = TaskManager()

    # Submit a task
    manager.submit_task('pick', ['object_id=box_1'])

    rclpy.spin(manager)
    rclpy.shutdown()
```

---

## Services vs Actions vs Topics: Decision Matrix

| Requirement | Use | Example |
|-------------|-----|---------|
| Fire-and-forget data streaming | Topic | Sensor data, camera images |
| Query current state | Service | Get joint positions, check battery |
| Quick computation (< 1s) | Service | Compute IK, validate input |
| Long task with feedback | Action | Navigate, grasp, follow trajectory |
| Need cancellation | Action | Navigation, manipulation tasks |
| Multiple subscribers needed | Topic | Sensor data to multiple nodes |
| Guaranteed delivery | Service/Action | Critical commands |

---

## Key Takeaways

- Services provide synchronous request-response for quick operations
- Actions support long-running, cancellable tasks with feedback
- Use services for state queries and fast computations (< 1s)
- Use actions for multi-step operations requiring progress monitoring
- Implement proper error handling, timeouts, and cancellation logic
- Both services and actions are built on topics under the hood
- Choose the right pattern based on duration, feedback needs, and cancellation requirements

## References

- [ROS 2 Services Documentation](https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Services/Understanding-ROS2-Services.html)
- [ROS 2 Actions Documentation](https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Actions/Understanding-ROS2-Actions.html)
- [rclpy Action API](https://docs.ros.org/en/humble/p/rclpy/api/actions.html)
- [rclpy Service API](https://docs.ros.org/en/humble/p/rclpy/api/services.html)

## Exercises

1. Create a service that computes forward kinematics for a robot arm
2. Build an action server for a multi-waypoint navigation task
3. Implement proper timeout handling for all service calls
4. Create a task scheduler that coordinates multiple actions

## Next Steps

In the next section, we'll create URDF robot models and learn how to visualize and control them in RViz and Gazebo.
